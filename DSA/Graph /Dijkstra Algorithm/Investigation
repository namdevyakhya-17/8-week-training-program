import java.io.*;
import java.util.*;

public class Investigation {

    static class Pair {
        int node;
        long cost;
        Pair(int node, long cost){
            this.node = node;
            this.cost = cost;
        }
    }

    static class Info {
        long cost;
        int min;
        int max;

        Info(long cost, int min, int max){
            this.cost = cost;
            this.min = min;
            this.max = max;
        }
    }

    public static void main(String[] args) throws Exception {

        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
        StringTokenizer st = new StringTokenizer(br.readLine());

        int n = Integer.parseInt(st.nextToken());
        int m = Integer.parseInt(st.nextToken());

        ArrayList<ArrayList<Pair>> graph = new ArrayList<>();

        for(int i=0;i<=n;i++)
            graph.add(new ArrayList<>());

        for(int i=0;i<m;i++){
            st = new StringTokenizer(br.readLine());

            int u = Integer.parseInt(st.nextToken());
            int v = Integer.parseInt(st.nextToken());
            int w = Integer.parseInt(st.nextToken());

            graph.get(u).add(new Pair(v,w));
        }

        Info[] dist = new Info[n+1];
        long[] ways = new long[n+1];
        long INF = Long.MAX_VALUE;
        for(int i=1;i<=n;i++){
            dist[i] = new Info(INF, Integer.MAX_VALUE, Integer.MIN_VALUE);
        }
        Arrays.fill(ways,0);
        dist[1] = new Info(0, 0, 0);
        ways[1] = 1;

        PriorityQueue<Pair> pq = new PriorityQueue<>((a,b)->Long.compare(a.cost,b.cost));
        pq.add(new Pair(1,0));
        int mod = 1000000007;

        while(!pq.isEmpty()){
            Pair curr = pq.poll();
            int u = curr.node;
            long cost = curr.cost;

            if(cost > dist[u].cost) continue;

            for(Pair edge : graph.get(u)){
                int v = edge.node;
                long w = edge.cost;
                long newCost = dist[u].cost + w;

                if(newCost < dist[v].cost){
                    dist[v].cost = newCost;
                    ways[v] = ways[u];
                    dist[v].min = dist[u].min + 1;
                    dist[v].max = dist[u].max + 1;
                    pq.add(new Pair(v,newCost));
                }

                else if(newCost == dist[v].cost){
                    ways[v] = (ways[v] + ways[u]) % mod;
                    dist[v].min = Math.min(dist[v].min, dist[u].min + 1);
                    dist[v].max = Math.max(dist[v].max, dist[u].max + 1);
                }
            }
        }

        BufferedWriter bw = new BufferedWriter(new OutputStreamWriter(System.out));

        bw.write(dist[n].cost + " "
                + ways[n] + " "
                + dist[n].min + " "
                + dist[n].max);

        bw.flush();
    }
}
