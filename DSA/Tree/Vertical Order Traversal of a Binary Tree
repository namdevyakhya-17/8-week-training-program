class Solution {
    class Tuple{
        int col;
        int row;
        TreeNode node;
        public Tuple(int col, int row, TreeNode node){
            this.col = col;
            this.row = row;
            this.node = node;
        }
    }
    public List<List<Integer>> verticalTraversal(TreeNode root) {
        TreeMap<Integer, TreeMap<Integer, PriorityQueue<Integer>>> map = new TreeMap<>();
        Queue<Tuple> q = new LinkedList<>();
        q.add(new Tuple(0,0,root));

        while(!q.isEmpty()){
            Tuple cur = q.poll();
            int cur_r = cur.row;
            int cur_c = cur.col;
            TreeNode cur_node = cur.node;

            map.putIfAbsent(cur_c, new TreeMap<>());
            map.get(cur_c).putIfAbsent(cur_r,new PriorityQueue<>());
            map.get(cur_c).get(cur_r).offer(cur_node.val);
            if(cur_node.left != null){
                q.add(new Tuple(cur_c-1, cur_r+1, cur_node.left));
            }
            if(cur_node.right != null){
                q.add(new Tuple(cur_c+1, cur_r+1, cur_node.right));
            }

        }

        List<List<Integer>> ans = new ArrayList<>();
        for(TreeMap<Integer, PriorityQueue<Integer>> rows: map.values()){
            List<Integer> temp = new ArrayList<>();
            for(PriorityQueue<Integer> pq: rows.values()){
                while(!pq.isEmpty()){
                    int value = pq.poll();
                    temp.add(value);
                }
            }
            ans.add(temp);
        }

        return ans;
    }
}


// More Optimised Way
class Solution {
    class Tuple{
        int col;
        int row;
        TreeNode node;
        public Tuple(int col, int row, TreeNode node){
            this.col = col;
            this.row = row;
            this.node = node;
        }
    }
    public List<List<Integer>> verticalTraversal(TreeNode root) {
        List<int[]> list = new ArrayList<>();
        Queue<Tuple> q = new LinkedList<>();
        q.add(new Tuple(0,0,root));

        while(!q.isEmpty()){
            Tuple t = q.poll();
            int r = t.row;
            int c = t.col;
            TreeNode node = t.node;
            list.add(new int[]{c,r,node.val});

            if(node.left != null){
                q.add(new Tuple(c-1,r+1,node.left));
            }
            if(node.right != null){
                q.add(new Tuple(c+1,r+1,node.right));
            }
        }

        Collections.sort(list, (a,b) -> {
            if(a[0] != b[0]) return a[0]-b[0];
            if(a[1] != b[1]) return a[1]-b[1];
            return a[2]-b[2];
        });

        List<List<Integer>> ans = new ArrayList<>();
        int prevCol = Integer.MIN_VALUE;
        for(int[] res: list){
            int col=res[0];
            int node_val = res[2];

            if(col != prevCol){
                prevCol = col;
                ans.add(new ArrayList<>());
            }
            ans.get(ans.size()-1).add(node_val);
        }
        return ans;
    }
}
