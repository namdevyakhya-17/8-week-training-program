class Solution {
    int[] dr = {-1,1,0,0};
    int[] dc = {0,0,-1,1};
    public int minimumEffortPath(int[][] heights) {
        int n = heights.length;
        int m = heights[0].length;

        PriorityQueue<int[]> q = new PriorityQueue<>((a,b) -> Integer.compare(a[2], b[2]));
        q.add(new int[]{0,0,0});
        boolean[][] visited = new boolean[n][m];

        while(!q.isEmpty()){
            int[] cur = q.poll();
            int i = cur[0];
            int j = cur[1];
            int hope = cur[2];

            if(visited[i][j]) continue;
            visited[i][j] = true;
            if(i==n-1 && j==m-1) return hope;

            for(int k=0; k<4; k++){
                int newi = i+dr[k];
                int newj = j+dc[k];
                if(newi>=0 && newj>=0 && newi<n && newj<m){
                    int minEffort = Math.max(hope, Math.abs(heights[i][j]-heights[newi][newj]));
                    q.add(new int[]{newi, newj, minEffort});
                }
            }
        }

        return -1;
    }
}
