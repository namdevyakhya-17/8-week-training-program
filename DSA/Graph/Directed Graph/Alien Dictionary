class Solution {
    public static String findOrder(String[] words) {
        HashMap<Character, ArrayList<Character>> graph = new HashMap<>();
        HashMap<Character, Integer> indegree = new HashMap<>();
        
        for(String word: words){
            for(char ch: word.toCharArray()){
                graph.putIfAbsent(ch,new ArrayList<>());
                indegree.putIfAbsent(ch,0);
            }
        }
        
        for(int i=0; i<words.length-1; i++){
            String word1 = words[i];
            String word2 = words[i+1];
            if(word1.startsWith(word2) && word1.length() > word2.length()) return "";
            
            int len = Math.min(word1.length(), word2.length());
            for(int j=0; j<len; j++){
                if(word1.charAt(j) != word2.charAt(j)){
                    graph.get(word1.charAt(j)).add(word2.charAt(j));
                    indegree.put(word2.charAt(j), indegree.getOrDefault(word2.charAt(j),0)+1);
                    
                    break;
                }
            }
            
        }
        
        Queue<Character> q = new LinkedList<>();
        for(Character ch : graph.keySet()){
            if(indegree.get(ch) == 0){
                q.add(ch);
            }
        }
        
        
        StringBuilder sb = new StringBuilder();
        while(!q.isEmpty()){
            char ch = q.poll();
            sb.append(ch);
            
            for(char adjCh: graph.get(ch)){
                indegree.put(adjCh, indegree.get(adjCh)-1);
                if(indegree.get(adjCh) == 0){
                    q.add(adjCh);
                }
            }
        }
        
        return sb.length() != graph.size() ? "" : sb.toString();
    }
}
