import java.io.BufferedReader;
import java.io.InputStreamReader;
import java.util.*;

// As constraint is 1<=n.m<=1000. So, don't prefer dfs for long grid as stack calls can get overflow
public class CountingRooms {
    static int[] dr = {-1,1,0,0};
    static int[] dc = {0,0,-1,1};

    public static void bfs(char[][] mat, int i, int j, boolean[][] visited){
        Queue<int[]> q = new LinkedList<>();
        q.add(new int[]{i,j});
        visited[i][j] = true;

        while (!q.isEmpty()) {
            int[] cur = q.poll();
            int r=cur[0];
            int c=cur[1];
            for(int k=0; k<4; k++){
                int nr = r+dr[k];
                int nc = c+dc[k];
                if(nr >= 0 && nr < mat.length && nc >= 0 && nc < mat[0].length && mat[nr][nc] == '.' && !visited[nr][nc]){
                    q.add(new int[]{nr,nc});
                    visited[nr][nc] = true;
                }
            }
        }
    }
    public static void main(String[] args) throws Exception {
        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
        StringTokenizer st = new StringTokenizer(br.readLine());

        int n = Integer.parseInt(st.nextToken());
        int m = Integer.parseInt(st.nextToken());

        char[][] mat = new char[n][m];
        for (int i = 0; i < n; i++) {
            mat[i] = br.readLine().toCharArray();
        }

        boolean[][] visited = new boolean[n][m];
        int rooms = 0;

        for (int i = 0; i < n; i++) {
            for (int j = 0; j < m; j++) {
                if (mat[i][j] == '.' && !visited[i][j]) {
                    bfs(mat, i, j, visited);
                    rooms++;
                }
            }
        }

        System.out.println(rooms);
    }
}
