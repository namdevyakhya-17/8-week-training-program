// Approach 1 - TLE for large Inout size
import java.util.*;
import java.io.*;
public class TeleportersPath {
    public static void dfs(ArrayList<Integer> ans, ArrayList<ArrayList<Integer>> graph, int node){
        while(!graph.get(node).isEmpty()){
            int v = graph.get(node).remove(graph.get(node).size()-1);
            System.out.println("Node " + node + ": " + v);
            dfs(ans, graph, v);
        }
        ans.add(node);
    }
    public static void main(String[] args) throws Exception{
        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
        StringTokenizer st = new StringTokenizer(br.readLine());
        int n = Integer.parseInt(st.nextToken());
        int m = Integer.parseInt(st.nextToken());
        ArrayList<ArrayList<Integer>> graph = new ArrayList<>();
        for(int i=0; i<=n; i++){
            graph.add(new ArrayList<>());
        }
        
        
        int[] indegree = new int[n+1];
        int[] outdegree = new int[n+1];
        for(int i=0; i<m; i++){
            st = new StringTokenizer(br.readLine());
            int u = Integer.parseInt(st.nextToken());
            int v = Integer.parseInt(st.nextToken());
            graph.get(u).add(v);
            indegree[v]++;
            outdegree[u]++;
        }

        for(int i=1; i<graph.size(); i++){
            for(int j=0; j<graph.get(i).size(); j++){
                System.out.print(i + ": " + graph.get(i).get(j) + " ");
            }
            System.out.println();
        }
        
        BufferedWriter bw = new BufferedWriter(new OutputStreamWriter(System.out));
        // Checking Euclidean's condition
        // Condition 1 => (outdegree[src] - indegree[src] = 1)
        // Condition 2 => (indegree[dest] - outdegree[dest] = 1)
        if((outdegree[1] - indegree[1] != 1) || (indegree[n] - outdegree[n] != 1)){
            bw.write("IMPOSSIBLE");
            bw.flush();
            return;
        }

        // Condition 3 => for rest nodes (indegree[node] == outdegree[node])
        for(int i=2; i<n; i++){
            if(indegree[i] != outdegree[i]){
                bw.write("IMPOSSIBLE");
                bw.flush();
                return;
            }
        }

        ArrayList<Integer> ans = new ArrayList<>();
        dfs(ans, graph, 1);

        if(ans.size() != m+1){
            bw.write("IMPOSSIBLE");
            bw.flush();
            return;
        }

        Collections.reverse(ans);
        for(int i=0; i<ans.size(); i++){
            bw.write(ans.get(i) + " ");
        }
        bw.flush();
    }
}

// More Optimised 
import java.io.*;
import java.util.*;

public class TeleportersPath {

    public static void main(String[] args) throws Exception {

        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
        StringTokenizer st = new StringTokenizer(br.readLine());

        int n = Integer.parseInt(st.nextToken());
        int m = Integer.parseInt(st.nextToken());

        ArrayList<ArrayList<Integer>> graph = new ArrayList<>();

        for(int i=0;i<=n;i++)
            graph.add(new ArrayList<>());

        int[] indegree = new int[n+1];
        int[] outdegree = new int[n+1];

        for(int i=0;i<m;i++){
            st = new StringTokenizer(br.readLine());

            int u = Integer.parseInt(st.nextToken());
            int v = Integer.parseInt(st.nextToken());

            graph.get(u).add(v);

            indegree[v]++;
            outdegree[u]++;
        }

        BufferedWriter bw = new BufferedWriter(new OutputStreamWriter(System.out));

        // Euler path condition check

        if(outdegree[1] - indegree[1] != 1 ||
           indegree[n] - outdegree[n] != 1){
            bw.write("IMPOSSIBLE");
            bw.flush();
            return;
        }

        for(int i=2;i<n;i++){
            if(indegree[i] != outdegree[i]){
                bw.write("IMPOSSIBLE");
                bw.flush();
                return;
            }
        }

        // Iterative Hierholzer
        Stack<Integer> stack = new Stack<>();
        ArrayList<Integer> path = new ArrayList<>();

        stack.push(1);

        while(!stack.isEmpty()){

            int node = stack.peek();

            if(graph.get(node).isEmpty()){
                path.add(node);
                stack.pop();
            }
            else{
                int next = graph.get(node).remove(graph.get(node).size()-1);
                stack.push(next);
            }
        }

        if(path.size() != m+1){
            bw.write("IMPOSSIBLE");
            bw.flush();
            return;
        }

        Collections.reverse(path);

        for(int x : path)
            bw.write(x + " ");

        bw.flush();
    }
}
