### TOP-DOWN APPROACH ###
class Solution {
    int max = 1_000_000_009;

    public int solve(int i, int j, int[][] dungeon, int [][] dp){
        if(i >= dungeon.length || j >= dungeon[0].length) return max;

        if(dp[i][j] != -1) return dp[i][j];

        // condition from back (m-1,n-1)th cell
        if(i == dungeon.length-1 && j == dungeon[0].length-1){
            if(dungeon[i][j] > 0) return 1;
            else return Math.abs(dungeon[i][j])+1;
        }

        int right = solve(i,j+1,dungeon,dp);
        int down = solve(i+1, j, dungeon,dp);

        // for rest of the cells
        int result = Math.min(right, down) - dungeon[i][j];

        return dp[i][j] = result <= 0 ? 1 : result;
    }
    public int calculateMinimumHP(int[][] dungeon) {
        int[][] dp = new int[dungeon.length+1][dungeon[0].length+1];   

        for(int[] dps: dp){
            Arrays.fill(dps, -1);
        }
        return solve(0,0,dungeon,dp);
    }
}



### BOTTOM-UP APPROACH ###
class Solution {
    int max = 1_000_000_009;

    public int calculateMinimumHP(int[][] dungeon) {
        int m = dungeon.length;
        int n = dungeon[0].length;
        int[][] dp = new int[m+1][n+1];   

        for(int[] dps: dp){
            Arrays.fill(dps, -1);
        }
        
        for(int i=m-1; i>=0; i--){
            for(int j=n-1; j>=0; j--){
                if(i == m-1 && j == n-1){
                    dp[i][j] = dungeon[i][j] > 0 ? 1 : Math.abs(dungeon[i][j]) + 1;
                }else{
                    int right = (j+1 < n) ? dp[i][j+1] : max;
                    int down = (i+1 < m) ? dp[i+1][j] : max;

                    int res = Math.min(right, down) - dungeon[i][j];
                    dp[i][j] = res <= 0 ? 1 : res;
                }
            }
        } 
        return dp[0][0];
    }
}
