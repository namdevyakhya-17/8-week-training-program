class Solution {
    public boolean isPalindrome(String s, int i, int j){
        while(i < j){
            if(s.charAt(i) != s.charAt(j)) return false;
            i++;
            j--;
        }
        return true;
    }

    public int solve(int i, String s){
        if(i == s.length()) return 0;

        int minCut = Integer.MAX_VALUE;
        for(int j=i; j<s.length(); j++){
            if(isPalindrome(s,i,j)){
                int cut = 1+solve(j+1,s);
                minCut=Math.min(minCut, cut);
            }
        }
        return minCut;
    }
    public int minCut(String s) {
        return solve(0,s) -1;
    }
}

## Memoization ##
class Solution {
    Integer[] dp;
    public boolean isPalindrome(String s, int i, int j){
        while(i < j){
            if(s.charAt(i) != s.charAt(j)) return false;
            i++;
            j--;
        }
        return true;
    }

    public int solve(int i, String s){
        if(i == s.length()) return 0;
        if(dp[i] != null) return dp[i];

        int minCut = Integer.MAX_VALUE;
        for(int j=i; j<s.length(); j++){
            if(isPalindrome(s,i,j)){
                int cut = 1+solve(j+1,s);
                minCut=Math.min(minCut, cut);
            }
        }
        return dp[i] = minCut;
    }
    public int minCut(String s) {
        dp = new Integer[s.length()];
        return solve(0,s) -1;
    }
}
