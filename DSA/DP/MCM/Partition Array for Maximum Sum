## RECURSION ##
class Solution {
    public int solve(int i,  int[] arr, int k){
        if(i == arr.length) return 0;

        int len = 0;
        int maxVal = Integer.MIN_VALUE;
        int ans = Integer.MIN_VALUE;

        for(int j=i; j<i+k && j<arr.length; j++){
            len++;
            maxVal = Math.max(maxVal, arr[j]);
            int cost = maxVal*len + solve(j+1, arr,k);
            ans = Math.max(ans, cost);
        }

        return ans;
    }
    public int maxSumAfterPartitioning(int[] arr, int k) {
        return solve(0,arr,k);
    }
}

## MEMOIZATION ##
class Solution {
    Integer[] dp;
    public int solve(int i,  int[] arr, int k){
        if(i == arr.length) return 0;
        if(dp[i] != null) return dp[i];

        int len = 0;
        int maxVal = Integer.MIN_VALUE;
        int ans = Integer.MIN_VALUE;

        for(int j=i; j<i+k && j<arr.length; j++){
            len++;
            maxVal = Math.max(maxVal, arr[j]);
            int cost = maxVal*len + solve(j+1, arr,k);
            ans = Math.max(ans, cost);
        }

        return dp[i] = ans;
    }
    public int maxSumAfterPartitioning(int[] arr, int k) {
        dp = new Integer[arr.length];
        return solve(0,arr,k);
    }
}

## TABULATION ##
class Solution {
    public int maxSumAfterPartitioning(int[] arr, int k) {
        int[] dp = new int[arr.length+1];
        
        for(int i=arr.length-1; i>=0; i--){
            int len = 0;
            int maxVal = Integer.MIN_VALUE;
            int ans = Integer.MIN_VALUE;

            for(int j=i; j<i+k && j<arr.length; j++){
                len++;
                maxVal = Math.max(maxVal, arr[j]);
                int cost = maxVal*len + dp[j+1];
                ans = Math.max(ans, cost);
            }
            dp[i] = ans;
        }

        return dp[0];
    }
}
