## MEMOIZATION ##
class Solution {
    Integer[][] dp;
    int MAX = (int) 1e9+7;
    public int palindromePartition(String s, int k) {
        int n = s.length();
        dp = new Integer[n][k + 1];
        return helper(s, 0, k);
    }

    public int helper(String s, int i, int k) {
        if (i == s.length() && k == 0) return 0;
        if (i == s.length() || k == 0) return MAX;

        if (dp[i][k] != null) return dp[i][k];

        int min = MAX;

        for (int j = i; j < s.length(); j++) {
            int cost = palindromeCount(s, i, j);
            min = Math.min(min, cost + helper(s, j + 1, k - 1));
        }

        return dp[i][k] = min;
    }

    public int palindromeCount(String s, int i, int j) {
        int count = 0;
        while (i < j) {
            if (s.charAt(i) != s.charAt(j)) count++;
            i++;
            j--;
        }
        return count;
    }
}

## TABULATION ##
class Solution {
    int MAX = (int) 1e9;

    public int palindromePartition(String s, int k) {
        int n = s.length();
        int[][] dp = new int[n + 1][k + 1];

        for (int i = 0; i <= n; i++) {
            for (int p = 0; p <= k; p++) {
                dp[i][p] = MAX;
            }
        }
        dp[n][0] = 0;

        for (int i = n - 1; i >= 0; i--) {
            for (int p = 1; p <= k; p++) {
                for (int j = i; j < n; j++) {
                    dp[i][p] = Math.min(dp[i][p], palindromeCount(s, i, j) + dp[j + 1][p - 1]);
                }
            }
        }

        return dp[0][k];
    }

    public int palindromeCount(String s, int i, int j) {
        int count = 0;
        while (i < j) {
            if (s.charAt(i) != s.charAt(j)) count++;
            i++;
            j--;
        }
        return count;
    }
}

## 
