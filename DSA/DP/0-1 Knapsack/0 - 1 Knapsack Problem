## RECURSION ##
class Solution {
    public int findValue(int W, int val[], int wt[], int idx){
        if(W == 0) return 0;
        if(idx == val.length || W < 0) return 0;
        
        if(wt[idx] > W){
            return findValue(W, val, wt, idx+1);
        }
        
        int include = val[idx] + findValue(W-wt[idx], val, wt, idx+1);
        int exclude = findValue(W, val, wt, idx+1);
        
        return Math.max(include, exclude);
        
    }
    public int knapsack(int W, int val[], int wt[]) {
        return findValue(W,val,wt,0);
    }
}

## MEMOIZATION ##
class Solution {
    public int findValue(int W, int val[], int wt[], int idx, int[][] dp){
        if(W == 0) return 0;
        if(idx == val.length || W < 0) return 0;
        if(dp[idx][W] != -1) return dp[idx][W];
        
        if(wt[idx] > W){
            return dp[idx][W] = findValue(W, val, wt, idx+1,dp);
        }
        
        int include = val[idx] + findValue(W-wt[idx], val, wt, idx+1,dp);
        int exclude = findValue(W, val, wt, idx+1,dp);
        
        return dp[idx][W] = Math.max(include, exclude);
        
    }
    public int knapsack(int W, int val[], int wt[]) {
        int n = val.length;
        int[][] dp = new int[n][W+1];
        for(int[] row: dp) Arrays.fill(row, -1);
        
        return findValue(W,val,wt,0,dp);
    }
}

## TABULATION ##
class Solution {

    public int knapsack(int W, int val[], int wt[]) {
        int n = val.length;
        int[][] dp = new int[n+1][W+1];
        for(int i=1; i<=n; i++){
            for(int j=1; j<=W; j++){
                if(wt[i-1] <= j){
                    dp[i][j] = Math.max(dp[i-1][j], val[i-1]+dp[i-1][j-wt[i-1]]);
                }else{
                    dp[i][j] = dp[i-1][j];
                }
            }
        }
        
        return dp[n][W];
    }
}

## SPACE OPTIMIZATION ##
class Solution {
    public int knapsack(int W, int val[], int wt[]) {
        int n = val.length;
        int[] prev = new int[W+1];
    
        
        for(int i=1; i<=n; i++){
            int[] cur = new int[W+1];
            for(int j=1; j<=W; j++){
                if(wt[i-1] <= j){
                    cur[j] = Math.max(prev[j], val[i-1]+prev[j-wt[i-1]]);
                }else{
                    cur[j] = prev[j];
                }
            }
            prev = cur;
        }
        
        return prev[W];
    }
}
