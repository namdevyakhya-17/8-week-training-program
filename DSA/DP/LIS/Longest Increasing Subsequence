## RECURSION ##
class Solution { 
    public int solve(int[] nums, int cur, int last){
        if(cur == nums.length) return 0;

        int notTake = solve(nums, cur+1, last);
        int take = 0;
        if(last == -1  || nums[cur] > nums[last]){
            take = 1+solve(nums, cur+1, cur);
        }

        return Math.max(take, notTake);
    }
    public int lengthOfLIS(int[] nums) {
        return solve(nums,0,-1);
    }
}

## MEMOIZATION ##
class Solution {
    public int solve(int[] nums, int cur, int last, int[][] dp){
        if(cur == nums.length) return 0;
        if(dp[cur][last+1] != -1) return dp[cur][last+1];

        int notTake = solve(nums, cur+1, last,dp);
        int take = 0;
        if(last == -1  || nums[cur] > nums[last]){
            take = 1+solve(nums, cur+1, cur,dp);
        }

        return dp[cur][last+1] = Math.max(take, notTake);
    }
    public int lengthOfLIS(int[] nums) {
        int[][] dp = new int[nums.length][nums.length+1];
        for(int[] row: dp) Arrays.fill(row, -1);
        return solve(nums,0,-1,dp);
    }
}

## TABULATION ## 
class Solution {
    public int lengthOfLIS(int[] nums) {
        int[] dp = new int[nums.length];
        Arrays.fill(dp, 1);

        for(int cur = 1; cur < nums.length; cur++){
            for(int prev = 0; prev < cur; prev++){
                if(nums[prev] < nums[cur]){
                    dp[cur] = Math.max(dp[cur], dp[prev]+1);
                }
            }
        }

        int max = 1;
        for(int i=0; i<nums.length; i++){
            max = Math.max(max, dp[i]);
        }

        return max;
    }
}


## BINARY SEARCH => when constraints are in 10 power 5 ##
class Solution {
    public int lowerBound(ArrayList<Integer> list, int target){
        int low = 0;
        int high = list.size()-1;
        while(low <= high){
            int mid = (low+high)/2;
            if(list.get(mid) >= target){
                high = mid-1;
            }else if(list.get(mid) < target){
                low = mid+1;
            }
        }
        return low;
    }
    public int lengthOfLIS(int[] nums) {
        ArrayList<Integer> list = new ArrayList<>();
        list.add(nums[0]);

        for(int i=1; i<nums.length; i++){
            if(nums[i] > list.get(list.size()-1)){
                list.add(nums[i]);
            }else{
                list.set(lowerBound(list, nums[i]), nums[i]);
            }
        }

        return list.size();
    }
}
