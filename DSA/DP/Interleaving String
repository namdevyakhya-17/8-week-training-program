## RECURSION ##
class Solution {
    // Using 2 pointers only
    public boolean solve(String s1, String s2, String s3, int i, int j){
        if(i < 0 && j < 0) return true;

        boolean ans = false;
        if(i >= 0 && s1.charAt(i) == s3.charAt(i+j+1)){
            ans = ans || solve(s1,s2,s3,i-1,j);
        }
        if(j >= 0 && s2.charAt(j) == s3.charAt(i+j+1)){
            ans = ans || solve(s1,s2,s3,i,j-1);
        }

        return ans;
        
    }

    // public boolean solve(String s1, String s2, String s3, int i, int j, int k){
    //     if(k <= 0){
    //         if(i <= 0 || j <= 0) return true;
    //         return false;
    //     }

    //     boolean ans = false;
    //     if(i >= 0 && s1.charAt(i) == s3.charAt(k)){
    //         ans = ans || solve(s1,s2,s3,i-1,j,k-1);
    //     }
    //     if(j >= 0 && s2.charAt(j) == s3.charAt(k)){
    //         ans = ans || solve(s1,s2,s3,i,j-1,k-1);
    //     }

    //     return ans;
        
    // }
    public boolean isInterleave(String s1, String s2, String s3) {
        int n = s1.length();
        int m = s2.length();
        int p = s3.length();
        if(n+m != p) return false;
        // return solve(s1,s2,s3,n-1,m-1,p-1);
        return solve(s1,s2,s3,n-1,m-1);
    }
}

## MEMOIZATION ##
class Solution {
    // Using 2 pointers only
    public boolean solve(String s1, String s2, String s3, int i, int j, Boolean[][] dp){
        if(i < 0 && j < 0) return true;
        if(i>=0 && j>=0 && dp[i][j] != null) return dp[i][j];  // any string idx should not be neagtive => we would not be able to check

        boolean ans = false;
        if(i >= 0 && s1.charAt(i) == s3.charAt(i+j+1)){
            ans = ans || solve(s1,s2,s3,i-1,j,dp);
        }
        if(j >= 0 && s2.charAt(j) == s3.charAt(i+j+1)){
            ans = ans || solve(s1,s2,s3,i,j-1,dp);
        }

        if(i>0 && j>0) dp[i][j] = ans;
        return ans;
    }
    public boolean isInterleave(String s1, String s2, String s3) {
        int n = s1.length();
        int m = s2.length();
        int p = s3.length();
        if(n+m != p) return false;

        Boolean[][] dp = new Boolean[n][m];
        return solve(s1,s2,s3,n-1,m-1,dp);
    }
}

## TABULATION ##
