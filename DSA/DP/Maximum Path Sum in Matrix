class Solution {
    public int solve(int[][] mat, int i, int j, int m, int n, int[][] dp){
        if(i < 0 || j < 0 || i >= m || j >= n) return Integer.MIN_VALUE;
        if(i == m-1) return mat[i][j];
        if(dp[i][j] != -1) return dp[i][j];
        
        int case1 = solve(mat, i+1, j-1, m,n,dp);
        int case2 = solve(mat, i+1, j, m, n,dp);
        int case3 = solve(mat, i+1, j+1, m, n,dp);
        
        return dp[i][j] = Math.max(case1, Math.max(case2, case3)) + mat[i][j];
    }
    public int maximumPath(int[][] mat) {
        int max = Integer.MIN_VALUE;
        
        for(int i=0; i<mat[0].length; i++){
            int[][] dp = new int[mat.length][mat[0].length];
            for(int[] row: dp) Arrays.fill(row, -1);
            
            max = Math.max(max, solve(mat, 0,i,mat.length,mat[0].length,dp));
        }
        
        return max;
    }
    
}


## TABULATION ##
class Solution {
    public int maximumPath(int[][] mat) {
        int m = mat.length;
        int n = mat[0].length;
        int dp[][] = new int[m][n];
        
        for(int i=0; i<n; i++){
            dp[m-1][i] = mat[m-1][i];
        }
        
        for(int i=m-2; i>=0; i--){
            for(int j=0; j<n; j++){
                int case1 = dp[i+1][j];
                int case2 = (j) > 0 ? dp[i+1][j-1] : Integer.MIN_VALUE;
                int case3 = (j < n-1) ? dp[i+1][j+1] : Integer.MIN_VALUE;
                
                dp[i][j] = mat[i][j] + Math.max(case1, Math.max(case2, case3));
            }
        }
        
        int max = Integer.MIN_VALUE;
        for(int i=0; i<n; i++){
            max = Math.max(max, dp[0][i]);
        }
        
        return max;
    }
    
}
