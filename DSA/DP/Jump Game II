## RECURSION ## 
class Solution {
    public int solve(int[] nums, int i) {
        if (i >= nums.length - 1) return 0;

        int res = Integer.MAX_VALUE;

        for (int steps = 1; steps <= nums[i]; steps++) {
            if (i + steps < nums.length) {
                int next = solve(nums, i + steps);
                if (next != Integer.MAX_VALUE) {
                    res = Math.min(res, 1 + next);
                }
            }
        }
        return res;
    }

    public int jump(int[] nums) {
        return solve(nums, 0);
    }
}

## MEMOIZATION ##
class Solution {
    public int solve(int[] nums, int i,int[] dp) {
        if (i >= nums.length - 1) return 0;
        if(dp[i] != -1) return dp[i];

        int res = Integer.MAX_VALUE;

        for (int steps = 1; steps <= nums[i]; steps++) {
            if (i + steps < nums.length) {
                int next = solve(nums, i + steps,dp);
                if (next != Integer.MAX_VALUE) {
                    res = Math.min(res, 1 + next);
                }
            }
        }
        return dp[i] = res;
    }

    public int jump(int[] nums) {
        int[] dp = new int[nums.length];
        Arrays.fill(dp, -1);
        return solve(nums, 0,dp);
    }
}


## TABULATION ##
class Solution {
    public int jump(int[] nums) {
        int n = nums.length;
        int[] dp = new int[n];
        Arrays.fill(dp, Integer.MAX_VALUE);
        dp[0] = 0;

        for(int i=1; i<n; i++){
            for(int j=0; j<i; j++){
                if(j+nums[j] >= i && dp[j] != Integer.MAX_VALUE){
                    dp[i] = Math.min(dp[i], dp[j]+1);
                }
            }
        }
        return dp[n-1];
    }
}
