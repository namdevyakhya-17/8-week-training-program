class Solution {
    // sorting => row (inc.), col(dec.)

    public int maxEnvelopes(int[][] envelopes) {
        Arrays.sort(envelopes, (a,b) -> {
            if(a[0] != b[0]) return a[0]-b[0];
            return b[1]-a[1];
        });

        int n = envelopes.length;
        int[] lis = new int[n];  // storing heights in array
        for(int i=0; i<n; i++){
            lis[i] = envelopes[i][1];
        }

        // as constraint in 10^5 so applying the LIS using Binary search
        List<Integer> list = new ArrayList<>();
        list.add(lis[0]);
        for(int i=1; i<n; i++){
            if(lis[i] > list.get(list.size()-1)){
                list.add(lis[i]);
            }else{
                list.set(lowerBound(list,lis[i]), lis[i]);
            }
        }

        return list.size();
    }

    public int lowerBound(List<Integer> list, int target){
        int low = 0;
        int high = list.size()-1;
        while(low <= high){
            int mid = (low+high)/2;

            if(list.get(mid) >= target){
                high = mid-1;
            }else{
                low = mid+1;
            }
        }
        return low;
    }
}
