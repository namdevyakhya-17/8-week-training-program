## RECURSION ##
class Solution {
    public int solve(int[] nums, int cur, int last){
        if(cur == nums.length) return 0;

        int notTake = solve(nums, cur+1, last);
        int take = 0;
        if(last == -1  || nums[cur] > nums[last]){
            take = 1+solve(nums, cur+1, cur);
        }

        return Math.max(take, notTake);
    }
    public int lengthOfLIS(int[] nums) {
        return solve(nums,0,-1);
    }
}

## MEMOIZATION ##
class Solution {
    public int solve(int[] nums, int cur, int last, int[][] dp){
        if(cur == nums.length) return 0;
        if(dp[cur][last+1] != -1) return dp[cur][last+1];

        int notTake = solve(nums, cur+1, last,dp);
        int take = 0;
        if(last == -1  || nums[cur] > nums[last]){
            take = 1+solve(nums, cur+1, cur,dp);
        }

        return dp[cur][last+1] = Math.max(take, notTake);
    }
    public int lengthOfLIS(int[] nums) {
        int[][] dp = new int[nums.length][nums.length+1];
        for(int[] row: dp) Arrays.fill(row, -1);
        return solve(nums,0,-1,dp);
    }
}

## TABULATION ## 
class Solution {
    public int lengthOfLIS(int[] nums) {
        int[] dp = new int[nums.length];
        Arrays.fill(dp, 1);

        for(int cur = 1; cur < nums.length; cur++){
            for(int prev = 0; prev < cur; prev++){
                if(nums[prev] < nums[cur]){
                    dp[cur] = Math.max(dp[cur], dp[prev]+1);
                }
            }
        }

        int max = 1;
        for(int i=0; i<nums.length; i++){
            max = Math.max(max, dp[i]);
        }

        return max;
    }
}
